### 2. **XSS: Экранирование HTML/JS, CSP заголовки**
```typescript
// Fastify middleware для CSP
import fastify from 'fastify';
const app = fastify();

app.addHook('onSend', (request, reply, payload, done) => {
  reply.header(
    "Content-Security-Policy",
    "default-src 'self'; script-src 'self' 'unsafe-inline'"
  );
  done();
});

// Экранирование HTML (используем DOMPurify)
import DOMPurify from 'dompurify';
import { JSDOM } from 'jsdom';

const { window } = new JSDOM('');
const purify = DOMPurify(window);

const cleanHTML = purify.sanitize(userInput); // Очистка перед выводом в шаблон
```

---



# XSS 

## 1. Клиент (Frontend — TypeScript + Babylon.js + HTML UI)

* **Типы XSS: DOM-based XSS, XSS через вставку данных из API, URL, параметров.**

### Как защититься:

* **Экранировать (sanitize) любые данные перед вставкой в DOM, если они вставляются как HTML.**
  Но лучше **вставлять данные как текст** (например, через `textContent`, а не `innerHTML`).

* Если нужно вставить пользовательские строки в DOM, **использовать только методы безопасной вставки:**

```ts
const div = document.createElement('div');
div.textContent = userInput; // безопасно, т.к. вставляется текст
parent.appendChild(div);
```

* **Не вставлять в DOM необработанный HTML из ответа API или URL без фильтрации.**

* Для динамического рендеринга избегать `innerHTML` с данными из ненадёжных источников.

* **Для параметров из URL:** при чтении и использовании — валидировать и очищать их. Например, если параметр должен быть числом или одним из нескольких значений, проверять это.

* **Обновление UI:** Например, при показе имени пользователя в чате — вставлять имя как текст, а не как HTML.

---

## 2. Backend (Fastify API)

* **Здесь XSS чаще возникает через отдачу HTML с данными, введёнными пользователями.**

### Что делать:

* **Отдавать JSON (API) без HTML, если можно.** Если отдаётся HTML — обязательно фильтровать/экранировать пользовательские данные на сервере.

* **Если есть рендеринг шаблонов с пользовательскими данными, реализовать свою функцию эскейпинга HTML спецсимволов** (например, заменять `<` на `&lt;`, `>` на `&gt;` и т.п.)

* Добавить заголовок Content-Security-Policy (CSP) в ответах:

```ts
app.addHook('onSend', (request, reply, payload, done) => {
  reply.header(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self'"
  );
  done();
});
```

* **CSP ограничит выполнение сторонних скриптов и inline-JS, что сильно уменьшит вероятность успешного XSS.**

---

## 3. Чат-сервер (TCP + WS)

* Обычно он просто пересылает сообщения, но сообщения могут содержать вредоносный JS-код.

### Что делать:

* На стороне клиента **обязательно экранировать все сообщения при выводе** (см. пункт 1).

* Сервер может валидацию делать, например: ограничивать длину сообщений, запрещать или фильтровать подозрительные символы (опционально).

* **Не вставлять в серверные логи или ответы необработанный HTML.**

---

## 4. База данных (SQLite)

* Здесь XSS — косвенная угроза: если в базе хранятся опасные данные (например, имена, сообщения), то при отдаче их надо правильно экранировать.

* На уровне базы обычно **выполнять параметризованные запросы** (чтобы избежать SQL-инъекций), а XSS надо контролировать на уровне API и клиента.

---

# Резюме: куда и что добавлять

| Компонент         | Где вставлять защиту                       | Как реализовать                                                                                                 |
| ----------------- | ------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| **Frontend UI**   | При вставке данных из API/пользователя     | Вставлять через `.textContent` вместо `.innerHTML`, валидировать URL-параметры, избегать unsafe-inline скриптов |
| **Backend API**   | В API-ответах, HTML (если есть)            | Собственная функция экранирования HTML (`<`, `>`, `&`, `"`, `'`), добавление CSP заголовков Fastify             |
| **Chat сервер**   | При пересылке сообщений (серверная логика) | Минимальная валидация, но основной фильтр — клиент                                                              |
| **DB (SQLite)**   | При сохранении и отдаче данных             | Параметризованные запросы, фильтрация на уровне API/клиента                                                     |
| **CSP Заголовки** | В Fastify, на все HTTP ответы              | Добавить `Content-Security-Policy` хедер с ограничениями на скрипты и источники                                 |

---

# Пример простой функции экранирования HTML (на backend или frontend)

```ts
function escapeHTML(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}
```

---

# Итог

* **Везде, где выводятся пользовательские данные, НЕ вставлять их как HTML без экранирования.**
* **Использовать CSP для ограничения запуска JS.**
* **Валидация и ограничение данных при приёме (на сервере и клиенте).**
* **Все пользовательские сообщения и имена — обязательно экранировать перед выводом.**


[Что такое CSP](https://github.com/OnnaMcadva/P_Pong/blob/main/injections/CSP.md)
